useDynLib(Rmpfr, .registration=TRUE)

##-- From 'gmp' (on which we 'Depend' ------------------------------------------

## cheap, somewhat experimental -- hence the "."
export(.mpfr2bigz, .bigz2mpfr, .bigq2mpfr)

## Radical(but gets all): import("methods")
## try to import all we need, but not more
importFrom("methods", coerce, "coerce<-",
           setClass, setClassUnion, setMethod, setOldClass,
	   setValidity, slot, "slot<-",
	   getDataPart, setDataPart, getClass, getClassDef,
	   callGeneric, as, is, extends,
	   new, validObject,
	   signature, representation, prototype
           ## as we define methods for them:
           , show
           , Arith, Compare, Logic, Math, Math2, Ops, Summary
           ## needed implicitly [or "bug" ..]:
           , loadMethod)

importFrom("utils", str)
importFrom("stats", stats__pnorm = pnorm)# import *and* rename !
importClassesFrom("gmp", "bigz", "bigq")
importFrom("gmp"
           , asNumeric, .as.char.bigz, ..as.bigz
           , crossprod, tcrossprod# `%*%`, <- as we write (S4) methods for those
	   ## more to come
           , is.whole, formatN # because we add own S3 methods
	   )
if(packageVersion("gmp") >= "0.5.8")
    importFrom("gmp", is.matrixZQ, #-> R/gmp-convert.R
               which.min, which.max)# the generics
##------------------------------------------------------------------------------

exportClasses("mpfr1", "mpfr"
              , "mpfrArray"
              , "mpfrMatrix"

              , "atomicVector"
              , "array_or_vector"
              , "Mnumber"

              ## new, *not* containing "matrix" (which has -> "character"!):
              , "numericVector"
              , "mNumber"
)

export(.mpfr, .mpfr.
       ## ".Arith.codes"
       ## , ".Arith.mpfr.num"
       ## , ".Arith.num.mpfr"
       ## , ".Compare.codes"
       ## , ".Compare.codesRev"
       ## , ".Compare.mpfr.num"
       ## , ".Compare.num.mpfr"
       ## , ".Math.codes"
       ## , ".Math.gen"
       ## , ".Summary.codes"
       ## , ".abs.mpfr"
       ## , ".dimCheck"
       , ".getPrec"
       , ".getSign"
       ## , ".mA.subAssign"
       ## , ".matmult.R"
       ## , ".mpfr.debug"
       , ".mpfr.negative"
       ## , ".mpfr.negative.R"
       ## , ".mpfr.repl"
       , ".mpfr.sign"
       ## , ".mpfr.subset"
       , ".mpfr2str"
       ## , ".mpfrA.subset"
       ## , ".mpfrVersion"
       ## , ".packageName"
       ## , ".print.mpfr"
       ## , ".requireCachedGenerics"
       , "Ai"
       , "Bernoulli"
       , "Const"
       , "Ei"
       , "Li2"
       , "all.equal"
       , "aperm"
       , "apply" ## <- we make it S4 generic
       , "as.vector"
       , "atan2"
       , "beta" , "lbeta"
       ## S3 "c.mpfr"
       , "cbind"
       , "chooseMpfr", "chooseMpfr.all", "sumBinomMpfr"
       , "crossprod"
       , "erf" , "erfc"
       , "factorial"
       , "factorialMpfr"
       , "format"
       , "formatMpfr"
       , "getD"
       , "getPrec"
       , "hypot"
       , "integrateR"
       , "j0" , "j1" , "jn"
       , "mean"
       , "mpfr"
       , "mpfr.is.0"
       , "mpfr.is.integer"
       , "mpfr2array"
       , "mpfrArray"
       , "mpfrVersion"
       , "mpfr_default_prec"
       , "optimizeR"
       , "hjkMpfr" ## <-- FIXME, rather part of an  optimR(...., method = "hjk")
       , "pbetaI"
       , "pmax", "pmin"
       , "pnorm"
       , "pochMpfr"
       , "print.integrate"
       , "rbind"
       , "roundMpfr"
       , "seqMpfr"
       , "t"
       , "tcrossprod"
       , "toNum"
       , "unique"
       , "unirootR"
       , "y0", "y1", "yn"
       , "zeta"
       )


exportMethods(
              ##___ "own generics" ___
              "apply", "asNumeric",

              ##___ "other generics" ___

	      ## Group Methods
	      "Arith",
	      "Compare",
	      "Logic",
	      "Math",
	      "Math2",
	      "Ops",
	      "Summary",

              "abs", "log", "sign"
              , "all.equal", "aperm"
              , "as.vector", "as.integer", "as.numeric"
              , "coerce", "coerce<-"
              , "cbind", "rbind"
	      , "diag", "diag<-"
              , "dim", "dim<-", "dimnames", "dimnames<-"
              , "atan2", "beta", "lbeta"
              , "factorial"
              , "is.finite", "is.infinite", "is.na", "is.nan"
              , "%*%", "crossprod", "tcrossprod", "t"
              , "format"
              , "mean", "pmax", "pmin"
              , "show", "unique"
              , "colSums", "colMeans"
              , "rowSums", "rowMeans"
              , "which.min", "which.max"
)


S3method(c, mpfr)

S3method(as.array, mpfr)
S3method(as.matrix, mpfr)

S3method(determinant, mpfrMatrix)
S3method(scale, mpfrMatrix)

S3method(diff, mpfr)
S3method(str,  mpfr)

S3method(is.whole, mpfr)
S3method(formatN, mpfr)

S3method(print, mpfr)
S3method(print, mpfr1)
S3method(print, mpfrArray)

## useful, to have  base::outer() work automatically:
S3method(rep, mpfr)
S3method(t, mpfr)
S3method(t, mpfrMatrix)
S3method(aperm, mpfrArray)
