2) NOTA BENE:  Have  "mpfrMatrix", dim(.) <- ..; t(), %*%, crossprod()...

 -  <mpfr> %*% <mpfr>    should work like with numeric vectors
 -  <mpfr> %*% t(<mpfr>)  ditto

 -  <mpfr>[i] & <mpfrMatrix>[i]  work
    but   <mpfrMatrix> [i,j]  not yet

 -->  want things to work like
          which(<mpfrMatrix> == ., arr.ind = TRUE)  - ok
          outer(....)                               - not yet

 [No longer sure if this is true :]
 For this, we must ensure that the methods are used, instead of the
 .Primitive  base functions :

 One way: --> see ~/R/MM/NUMERICS/bessel-large-x.R
                  --------------------------------

  ## really interesting is  bI(x., nu)  {for "mpfr" argument}:
  ## it uses outer(), but that needs to dispatch on, e.g. "^",
  ## i.e., not only look at "base"
  environment(outer) <- as.environment("package:Rmpfr")
  environment(dim) <- as.environment("package:Rmpfr")
  environment(dimnames) <- as.environment("package:Rmpfr")
  environment(`dim<-`) <- as.environment("package:Rmpfr")
  environment(`dimnames<-`) <- as.environment("package:Rmpfr")
  environment(which) <- as.environment("package:Rmpfr")


4) format() should get more (optional) arguments; e.g. an option to
    [ round() after decimal ], and one to drop trailing zeros,
   see format.default

5) I'd like seq() methods, but that seems currently impossible because of
   a "design infelicity" in base::seq.default  --- ???? E-mail to R-core ??
   --> R/mpfr.R

6) It is "wrong" that the class "Mnumber" also extends "character", "list";
   but it's not clear we can find better definitions, see R/AllClasses.R

7) Add tests for hypot() & atan2() to tests/special-fun-ex.R

8) round(x, .) & signif(x, .) currently return "mpfr" numbers of the same precision.
   That *looks* ugly.
   Potentially add a swith 'keepPrec = FALSE' -- i.e. by default *reduce*
   precision to "match" 'digits' argument.

9) median(mpfr(1:4, 60)) now fails, but mean(.) and quantile() both work.
   ------ The infelicity could be seen in the way namespaces work :
   median.default() calls the correct sort() on "mpfr", but calls the *wrong*
   base::mean() instead of mean() {which is S4 by then} ....
   all would be fine if  base::mean() was *already* S4 generic ....
   of course I could replace base::mean() by the S4 generic on
   package-load time, but would prefer a cleaner solution.
   ---> talk to Luke and John (and ??) about that

10) [l]choose()       "should" be implemented {based on lgamma()}
    (===>  ~/R/MM/Pkg-ex/Rmpfr/binom-coef.R )
    possibly via a factorialMPFR() which automatically
    uses full precision for integer-valued argument, notably using MPFR's mpfr_fac_ui;
    see also end of man/mpfr-class.Rd

    [a C level implementation, using MPFR-structs instead of R's "mpfr",
     would be considerably faster, both for the  prod(...) case {for
     small k} but possibly also using lgamma() and arithmetic the MPFR C
     level rather than all via R objects].

11) format() method for "mpfrArray" (and hence "mpfrMatrix") which nicely
    and correctly *jointly* formats and aligns  columns !
    drop0trailing is not really sensible there

11b) format(<mpfr>) --> .mpfr2str() -> C mpfr2str()  still suffers from a
     memory bug, inspite of my efforts in src/convert.c
     I think this is the MPFR library just allocating memory that's in use
     by R, but it seems hard to prove and or fix that.

12) crossprod(), tcrossprod() (and more?) methods for "mpfrMatrix".

13) implement the  NOT_YET  in src/Ops.c

14) Want to *change*  'precBits' of existing MPFR numbers;
    MPFR has  mpfr_set_prec(X, PREC)  but that sets the value to NaN.
    Manual:  "In case you want to keep the previous value stored in X, use
               `mpfr_prec_round' instead."
    -->  mpfr_prec_round(X, PREC, RND)


50) For *complex* arithmetic, build interface to the  "MPC" library
   ---> http://www.multiprecision.org/mpc -- which is LGPL and itself
   builds on MPFR and GMP.
